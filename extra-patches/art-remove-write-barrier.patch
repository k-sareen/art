diff --git a/build/Android.common_build.mk b/build/Android.common_build.mk
index 08962526dd..0ec22c201c 100644
--- a/build/Android.common_build.mk
+++ b/build/Android.common_build.mk
@@ -48,6 +48,8 @@ endif
 
 # Enable the read barrier by default.
 ART_USE_READ_BARRIER ?= true
+# Enable the write barrier by default.
+ART_USE_WRITE_BARRIER ?= true
 
 # Default compact dex level to none.
 ifeq ($(ART_DEFAULT_COMPACT_DEX_LEVEL),)
diff --git a/build/art.go b/build/art.go
index 0ada8702f4..a3130232b6 100644
--- a/build/art.go
+++ b/build/art.go
@@ -80,6 +80,18 @@ func globalFlags(ctx android.LoadHookContext) ([]string, []string) {
 		tlab = true
 	}
 
+	if ctx.Config().IsEnvTrue("ART_USE_WRITE_BARRIER") {
+		cflags = append(cflags,
+			"-DART_USE_WRITE_BARRIER=1")
+		asflags = append(asflags,
+			"-DART_USE_WRITE_BARRIER=1")
+	} else {
+		cflags = append(cflags,
+			"-DART_USE_WRITE_BARRIER=0")
+		asflags = append(asflags,
+			"-DART_USE_WRITE_BARRIER=0")
+	}
+
 	if tlab {
 		cflags = append(cflags, "-DART_USE_TLAB=1")
 	}
diff --git a/compiler/optimizing/code_generator.h b/compiler/optimizing/code_generator.h
index cd44fb3fa7..8deb4c330f 100644
--- a/compiler/optimizing/code_generator.h
+++ b/compiler/optimizing/code_generator.h
@@ -37,6 +37,7 @@
 #include "oat_quick_method_header.h"
 #include "optimizing_compiler_stats.h"
 #include "read_barrier_option.h"
+#include "write_barrier_config.h"
 #include "stack.h"
 #include "subtype_check.h"
 #include "utils/assembler.h"
@@ -501,9 +502,13 @@ class CodeGenerator : public DeletableArenaObject<kArenaAllocCodeGenerator> {
   }
 
   static bool StoreNeedsWriteBarrier(DataType::Type type, HInstruction* value) {
-    // Check that null value is not represented as an integer constant.
-    DCHECK_IMPLIES(type == DataType::Type::kReference, !value->IsIntConstant());
-    return type == DataType::Type::kReference && !value->IsNullConstant();
+    if (gUseWriteBarrier) {
+      // Check that null value is not represented as an integer constant.
+      DCHECK_IMPLIES(type == DataType::Type::kReference, !value->IsIntConstant());
+      return type == DataType::Type::kReference && !value->IsNullConstant();
+    } else {
+      return false;
+    }
   }
 
 
diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index a4e4f46129..c558e6f74b 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -3003,7 +3003,7 @@ void InstructionCodeGeneratorARM64::VisitArraySet(HArraySet* instruction) {
       }
     }
 
-    if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
+    if (needs_write_barrier && instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
       DCHECK_EQ(instruction->GetWriteBarrierKind(), WriteBarrierKind::kEmitNoNullCheck)
           << " Already null checked so we shouldn't do it again.";
       codegen_->MarkGCCard(array, value.W(), /* emit_null_check= */ false);
diff --git a/compiler/optimizing/code_generator_arm_vixl.cc b/compiler/optimizing/code_generator_arm_vixl.cc
index 09f40c2996..b5b309d669 100644
--- a/compiler/optimizing/code_generator_arm_vixl.cc
+++ b/compiler/optimizing/code_generator_arm_vixl.cc
@@ -7016,7 +7016,7 @@ void InstructionCodeGeneratorARMVIXL::VisitArraySet(HArraySet* instruction) {
         }
       }
 
-      if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
+      if (needs_write_barrier && instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
         DCHECK_EQ(instruction->GetWriteBarrierKind(), WriteBarrierKind::kEmitNoNullCheck)
             << " Already null checked so we shouldn't do it again.";
         codegen_->MarkGCCard(temp1, temp2, array, value, /* emit_null_check= */ false);
diff --git a/compiler/optimizing/code_generator_x86.cc b/compiler/optimizing/code_generator_x86.cc
index 190361a5ce..57d1b8230d 100644
--- a/compiler/optimizing/code_generator_x86.cc
+++ b/compiler/optimizing/code_generator_x86.cc
@@ -6462,9 +6462,12 @@ void LocationsBuilderX86::VisitArraySet(HArraySet* instruction) {
   } else {
     locations->SetInAt(2, Location::RegisterOrConstant(instruction->InputAt(2)));
   }
-  if (needs_write_barrier) {
-    // Used by reference poisoning or emitting write barrier.
+  // Need a temporary for the kReference type for reference poisoning
+  if (value_type == DataType::Type::kReference && !(instruction->GetValue())->IsNullConstant()) {
     locations->AddTemp(Location::RequiresRegister());
+  }
+  if (needs_write_barrier) {
+    // Used for emitting write barrier.
     if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
       // Only used when emitting a write barrier. Ensure the card is in a byte register.
       locations->AddTemp(Location::RegisterLocation(ECX));
@@ -6526,7 +6529,7 @@ void InstructionCodeGeneratorX86::VisitArraySet(HArraySet* instruction) {
         break;
       }
 
-      DCHECK(needs_write_barrier);
+      // DCHECK(needs_write_barrier);
       Register register_value = value.AsRegister<Register>();
       Location temp_loc = locations->GetTemp(0);
       Register temp = temp_loc.AsRegister<Register>();
@@ -6585,7 +6588,7 @@ void InstructionCodeGeneratorX86::VisitArraySet(HArraySet* instruction) {
         }
       }
 
-      if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
+      if (needs_write_barrier && instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
         DCHECK_EQ(instruction->GetWriteBarrierKind(), WriteBarrierKind::kEmitNoNullCheck)
             << " Already null checked so we shouldn't do it again.";
         Register card = locations->GetTemp(1).AsRegister<Register>();
diff --git a/compiler/optimizing/code_generator_x86_64.cc b/compiler/optimizing/code_generator_x86_64.cc
index df83089917..930e6ec0a2 100644
--- a/compiler/optimizing/code_generator_x86_64.cc
+++ b/compiler/optimizing/code_generator_x86_64.cc
@@ -5771,9 +5771,13 @@ void LocationsBuilderX86_64::VisitArraySet(HArraySet* instruction) {
     locations->SetInAt(2, Location::RegisterOrConstant(instruction->InputAt(2)));
   }
 
-  if (needs_write_barrier) {
-    // Used by reference poisoning or emitting write barrier.
+  // Need a temporary for the kReference type for reference poisoning
+  if (value_type == DataType::Type::kReference && !(instruction->GetValue())->IsNullConstant()) {
     locations->AddTemp(Location::RequiresRegister());
+  }
+
+  if (needs_write_barrier) {
+    // Used for emitting write barrier.
     if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
       // Only used when emitting a write barrier.
       locations->AddTemp(Location::RequiresRegister());
@@ -5836,7 +5840,7 @@ void InstructionCodeGeneratorX86_64::VisitArraySet(HArraySet* instruction) {
         break;
       }
 
-      DCHECK(needs_write_barrier);
+      // DCHECK(needs_write_barrier);
       CpuRegister register_value = value.AsRegister<CpuRegister>();
       Location temp_loc = locations->GetTemp(0);
       CpuRegister temp = temp_loc.AsRegister<CpuRegister>();
@@ -5895,7 +5899,7 @@ void InstructionCodeGeneratorX86_64::VisitArraySet(HArraySet* instruction) {
         }
       }
 
-      if (instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
+      if (needs_write_barrier && instruction->GetWriteBarrierKind() != WriteBarrierKind::kDontEmit) {
         DCHECK_EQ(instruction->GetWriteBarrierKind(), WriteBarrierKind::kEmitNoNullCheck)
             << " Already null checked so we shouldn't do it again.";
         CpuRegister card = locations->GetTemp(1).AsRegister<CpuRegister>();
diff --git a/compiler/optimizing/intrinsics_arm64.cc b/compiler/optimizing/intrinsics_arm64.cc
index 2ec2134fb1..1ec7865d6d 100644
--- a/compiler/optimizing/intrinsics_arm64.cc
+++ b/compiler/optimizing/intrinsics_arm64.cc
@@ -975,7 +975,7 @@ static void GenUnsafePut(HInvoke* invoke,
     }
   }
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     bool value_can_be_null = true;  // TODO: Worth finding out this information?
     codegen->MarkGCCard(base, value, value_can_be_null);
   }
@@ -1433,7 +1433,7 @@ static void GenUnsafeCas(HInvoke* invoke, DataType::Type type, CodeGeneratorARM6
   Register new_value = RegisterFrom(locations->InAt(4), type);    // New value.
 
   // This needs to be before the temp registers, as MarkGCCard also uses VIXL temps.
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     // Mark card for object assuming new value is stored.
     bool new_value_can_be_null = true;  // TODO: Worth finding out this information?
     codegen->MarkGCCard(base, new_value, new_value_can_be_null);
@@ -3418,7 +3418,9 @@ void IntrinsicCodeGeneratorARM64::VisitSystemArrayCopy(HInvoke* invoke) {
   }
 
   // We only need one card marking on the destination array.
-  codegen_->MarkGCCard(dest.W(), Register(), /* emit_null_check= */ false);
+  if (gUseWriteBarrier) {
+    codegen_->MarkGCCard(dest.W(), Register(), /* emit_null_check= */ false);
+  }
 
   __ Bind(intrinsic_slow_path->GetExitLabel());
 }
diff --git a/compiler/optimizing/intrinsics_arm_vixl.cc b/compiler/optimizing/intrinsics_arm_vixl.cc
index d31593cf9f..cc2f9efa05 100644
--- a/compiler/optimizing/intrinsics_arm_vixl.cc
+++ b/compiler/optimizing/intrinsics_arm_vixl.cc
@@ -1723,7 +1723,9 @@ void IntrinsicCodeGeneratorARMVIXL::VisitSystemArrayCopy(HInvoke* invoke) {
   }
 
   // We only need one card marking on the destination array.
-  codegen_->MarkGCCard(temp1, temp2, dest, NoReg, /* emit_null_check= */ false);
+  if (gUseWriteBarrier) {
+    codegen_->MarkGCCard(temp1, temp2, dest, NoReg, /* emit_null_check= */ false);
+  }
 
   __ Bind(intrinsic_slow_path->GetExitLabel());
 }
@@ -3123,7 +3125,7 @@ static void GenUnsafePut(HInvoke* invoke,
                        maybe_temp2,
                        /*maybe_temp3=*/ Location::NoLocation());
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     vixl32::Register temp = RegisterFrom(locations->GetTemp(0));
     UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
     vixl32::Register card = temps.Acquire();
@@ -3695,7 +3697,7 @@ static void GenUnsafeCas(HInvoke* invoke, DataType::Type type, CodeGeneratorARMV
   UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
   vixl32::Register tmp_ptr = temps.Acquire();
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     // Mark card for object assuming new value is stored. Worst case we will mark an unchanged
     // object and scan the receiver at the next GC for nothing.
     bool value_can_be_null = true;  // TODO: Worth finding out this information?
diff --git a/compiler/optimizing/intrinsics_x86.cc b/compiler/optimizing/intrinsics_x86.cc
index 02f312e74e..6b570e481e 100644
--- a/compiler/optimizing/intrinsics_x86.cc
+++ b/compiler/optimizing/intrinsics_x86.cc
@@ -2020,7 +2020,7 @@ static void GenUnsafePut(LocationSummary* locations,
     codegen->MemoryFence();
   }
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     bool value_can_be_null = true;  // TODO: Worth finding out this information?
     codegen->MarkGCCard(locations->GetTemp(0).AsRegister<Register>(),
                         locations->GetTemp(1).AsRegister<Register>(),
@@ -2354,11 +2354,13 @@ static void GenReferenceCAS(HInvoke* invoke,
   }
 
   // Mark card for object if the new value is stored.
-  bool value_can_be_null = true;  // TODO: Worth finding out this information?
-  NearLabel skip_mark_gc_card;
-  __ j(kNotZero, &skip_mark_gc_card);
-  codegen->MarkGCCard(temp, temp2, base, value, value_can_be_null);
-  __ Bind(&skip_mark_gc_card);
+  if (gUseWriteBarrier) {
+    bool value_can_be_null = true;  // TODO: Worth finding out this information?
+    NearLabel skip_mark_gc_card;
+    __ j(kNotZero, &skip_mark_gc_card);
+    codegen->MarkGCCard(temp, temp2, base, value, value_can_be_null);
+    __ Bind(&skip_mark_gc_card);
+  }
 
   // If heap poisoning is enabled, we need to unpoison the values
   // that were poisoned earlier.
@@ -3258,7 +3260,9 @@ void IntrinsicCodeGeneratorX86::VisitSystemArrayCopy(HInvoke* invoke) {
   }
 
   // We only need one card marking on the destination array.
-  codegen_->MarkGCCard(temp1, temp2, dest, Register(kNoRegister), /* emit_null_check= */ false);
+  if (gUseWriteBarrier) {
+    codegen_->MarkGCCard(temp1, temp2, dest, Register(kNoRegister), /* emit_null_check= */ false);
+  }
 
   __ Bind(intrinsic_slow_path->GetExitLabel());
 }
@@ -4209,8 +4213,10 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke, CodeGeneratorX86* codege
             /* always_update_field= */ true,
             &temp2);
       }
-      codegen->MarkGCCard(
-          temp, temp2, reference, value.AsRegister<Register>(), /* emit_null_check= */ false);
+      if (gUseWriteBarrier) {
+        codegen->MarkGCCard(
+            temp, temp2, reference, value.AsRegister<Register>(), /* emit_null_check= */ false);
+      }
       if (kPoisonHeapReferences) {
         __ movl(temp, value.AsRegister<Register>());
         __ PoisonHeapReference(temp);
diff --git a/compiler/optimizing/intrinsics_x86_64.cc b/compiler/optimizing/intrinsics_x86_64.cc
index 99da84408a..32be4004ec 100644
--- a/compiler/optimizing/intrinsics_x86_64.cc
+++ b/compiler/optimizing/intrinsics_x86_64.cc
@@ -1224,7 +1224,9 @@ void IntrinsicCodeGeneratorX86_64::VisitSystemArrayCopy(HInvoke* invoke) {
   }
 
   // We only need one card marking on the destination array.
-  codegen_->MarkGCCard(temp1, temp2, dest, CpuRegister(kNoRegister), /* emit_null_check= */ false);
+  if (gUseWriteBarrier) {
+    codegen_->MarkGCCard(temp1, temp2, dest, CpuRegister(kNoRegister), /* emit_null_check= */ false);
+  }
 
   __ Bind(intrinsic_slow_path->GetExitLabel());
 }
@@ -2148,7 +2150,7 @@ static void GenUnsafePut(LocationSummary* locations, DataType::Type type, bool i
     codegen->MemoryFence();
   }
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && gUseWriteBarrier) {
     bool value_can_be_null = true;  // TODO: Worth finding out this information?
     codegen->MarkGCCard(locations->GetTemp(0).AsRegister<CpuRegister>(),
                         locations->GetTemp(1).AsRegister<CpuRegister>(),
@@ -2443,8 +2445,10 @@ static void GenCompareAndSetOrExchangeRef(CodeGeneratorX86_64* codegen,
   X86_64Assembler* assembler = down_cast<X86_64Assembler*>(codegen->GetAssembler());
 
   // Mark card for object assuming new value is stored.
-  bool value_can_be_null = true;  // TODO: Worth finding out this information?
-  codegen->MarkGCCard(temp1, temp2, base, value, value_can_be_null);
+  if (gUseWriteBarrier) {
+    bool value_can_be_null = true;  // TODO: Worth finding out this information?
+    codegen->MarkGCCard(temp1, temp2, base, value, value_can_be_null);
+  }
 
   Address field_addr(base, offset, TIMES_1, 0);
   if (gUseReadBarrier && kUseBakerReadBarrier) {
@@ -4281,7 +4285,10 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke,
           &temp1,
           &temp2);
     }
-    codegen->MarkGCCard(temp1, temp2, ref, valreg, /* emit_null_check= */ false);
+
+    if (gUseWriteBarrier) {
+      codegen->MarkGCCard(temp1, temp2, ref, valreg, /*emit_null_check=*/ false);
+    }
 
     DCHECK_EQ(valreg, out.AsRegister<CpuRegister>());
     if (kPoisonHeapReferences) {
diff --git a/runtime/arch/arm/quick_entrypoints_arm.S b/runtime/arch/arm/quick_entrypoints_arm.S
index e2b5bca461..d8e6d405b2 100644
--- a/runtime/arch/arm/quick_entrypoints_arm.S
+++ b/runtime/arch/arm/quick_entrypoints_arm.S
@@ -727,9 +727,11 @@ ENTRY art_quick_aput_obj
     add r3, r0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
     POISON_HEAP_REF r2
     str r2, [r3, r1, lsl #2]
+#ifdef USE_WRITE_BARRIER
     ldr r3, [rSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr r0, r0, #CARD_TABLE_CARD_SHIFT
     strb r3, [r3, r0]
+#endif  // USE_WRITE_BARRIER
     blx lr
 
 .Laput_obj_null:
@@ -752,9 +754,11 @@ ENTRY art_quick_aput_obj
     add r3, r0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
     POISON_HEAP_REF r2
     str r2, [r3, r1, lsl #2]
+#ifdef USE_WRITE_BARRIER
     ldr r3, [rSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr r0, r0, #CARD_TABLE_CARD_SHIFT
     strb r3, [r3, r0]
+#endif  // USE_WRITE_BARRIER
     blx lr
 
 .Lthrow_array_store_exception:
diff --git a/runtime/arch/arm64/quick_entrypoints_arm64.S b/runtime/arch/arm64/quick_entrypoints_arm64.S
index 694c76a132..5b88266e52 100644
--- a/runtime/arch/arm64/quick_entrypoints_arm64.S
+++ b/runtime/arch/arm64/quick_entrypoints_arm64.S
@@ -1017,9 +1017,11 @@ ENTRY art_quick_aput_obj
     add x3, x0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
     POISON_HEAP_REF w2
     str w2, [x3, x1, lsl #2]                           // Heap reference = 32b.
+#ifdef USE_WRITE_BARRIER
     ldr x3, [xSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr x0, x0, #CARD_TABLE_CARD_SHIFT
     strb w3, [x3, x0]
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Laput_obj_null:
@@ -1048,9 +1050,11 @@ ENTRY art_quick_aput_obj
     add x3, x0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
     POISON_HEAP_REF w2
     str w2, [x3, x1, lsl #2]                           // Heap reference = 32b.
+#ifdef USE_WRITE_BARRIER
     ldr x3, [xSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr x0, x0, #CARD_TABLE_CARD_SHIFT
     strb w3, [x3, x0]
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Laput_obj_throw_array_store_exception:
diff --git a/runtime/arch/x86/quick_entrypoints_x86.S b/runtime/arch/x86/quick_entrypoints_x86.S
index 8fd854fc2a..644505e526 100644
--- a/runtime/arch/x86/quick_entrypoints_x86.S
+++ b/runtime/arch/x86/quick_entrypoints_x86.S
@@ -1294,9 +1294,11 @@ DEFINE_FUNCTION art_quick_aput_obj
 .Laput_obj_store:
     POISON_HEAP_REF edx
     movl %edx, MIRROR_OBJECT_ARRAY_DATA_OFFSET(%eax, %ecx, 4)
+#ifdef USE_WRITE_BARRIER
     movl %fs:THREAD_CARD_TABLE_OFFSET, %edx
     shrl LITERAL(CARD_TABLE_CARD_SHIFT), %eax
     movb %dl, (%edx, %eax)
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Laput_obj_null:
@@ -1329,9 +1331,11 @@ DEFINE_FUNCTION art_quick_aput_obj
     jz   .Lthrow_array_store_exception
     POISON_HEAP_REF edx
     movl %edx, MIRROR_OBJECT_ARRAY_DATA_OFFSET(%eax, %ecx, 4)  // Do the aput.
+#ifdef USE_WRITE_BARRIER
     movl %fs:THREAD_CARD_TABLE_OFFSET, %edx
     shrl LITERAL(CARD_TABLE_CARD_SHIFT), %eax
     movb %dl, (%edx, %eax)
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Lthrow_array_store_exception:
diff --git a/runtime/arch/x86_64/quick_entrypoints_x86_64.S b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
index 01d9133c18..0fc23948d8 100644
--- a/runtime/arch/x86_64/quick_entrypoints_x86_64.S
+++ b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
@@ -1215,9 +1215,11 @@ DEFINE_FUNCTION art_quick_aput_obj
 .Laput_obj_store:
     POISON_HEAP_REF edx
     movl %edx, MIRROR_OBJECT_ARRAY_DATA_OFFSET(%rdi, %rsi, 4)
+#ifdef USE_WRITE_BARRIER
     movq %gs:THREAD_CARD_TABLE_OFFSET, %rdx
     shrl LITERAL(CARD_TABLE_CARD_SHIFT), %edi
     movb %dl, (%rdx, %rdi)
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Laput_obj_null:
@@ -1243,9 +1245,11 @@ DEFINE_FUNCTION art_quick_aput_obj
     jz   .Laput_obj_throw_array_store_exception
     POISON_HEAP_REF edx
     movl %edx, MIRROR_OBJECT_ARRAY_DATA_OFFSET(%rdi, %rsi, 4)
+#ifdef USE_WRITE_BARRIER
     movq %gs:THREAD_CARD_TABLE_OFFSET, %rdx
     shrl LITERAL(CARD_TABLE_CARD_SHIFT), %edi
     movb %dl, (%rdx, %rdi)
+#endif  // USE_WRITE_BARRIER
     ret
 
 .Laput_obj_throw_array_store_exception:
diff --git a/runtime/gc/collector/semi_space.cc b/runtime/gc/collector/semi_space.cc
index 72257bf3f8..9bb316f524 100644
--- a/runtime/gc/collector/semi_space.cc
+++ b/runtime/gc/collector/semi_space.cc
@@ -40,7 +40,6 @@
 #include "indirect_reference_table.h"
 #include "intern_table.h"
 #include "jni/jni_internal.h"
-#include "mark_sweep-inl.h"
 #include "mirror/object-inl.h"
 #include "mirror/object-refvisitor-inl.h"
 #include "mirror/reference-inl.h"
@@ -179,11 +178,14 @@ void SemiSpace::MarkingPhase() {
   // Assume the cleared space is already empty.
   BindBitmaps();
   // Process dirty cards and add dirty cards to mod-union tables.
-  heap_->ProcessCards(GetTimings(), /*use_rem_sets=*/false, false, true);
-  // Clear the whole card table since we cannot get any additional dirty cards during the
-  // paused GC. This saves memory but only works for pause the world collectors.
-  t.NewTiming("ClearCardTable");
-  heap_->GetCardTable()->ClearCardTable();
+  if (gUseWriteBarrier) {
+    heap_->ProcessCards(GetTimings(), /*use_rem_sets=*/false, false, true);
+
+    // Clear the whole card table since we cannot get any additional dirty cards during the
+    // paused GC. This saves memory but only works for pause the world collectors.
+    t.NewTiming("ClearCardTable");
+    heap_->GetCardTable()->ClearCardTable();
+  }
   // Need to do this before the checkpoint since we don't want any threads to add references to
   // the live stack during the recursive mark.
   if (kUseThreadLocalAllocationStack) {
@@ -291,7 +293,7 @@ void SemiSpace::MarkReachableObjects() {
   for (auto& space : heap_->GetContinuousSpaces()) {
     // If the space is immune then we need to mark the references to other spaces.
     accounting::ModUnionTable* table = heap_->FindModUnionTableFromSpace(space);
-    if (table != nullptr) {
+    if (gUseWriteBarrier && table != nullptr) {
       // TODO: Improve naming.
       TimingLogger::ScopedTiming t2(
           space->IsZygoteSpace() ? "UpdateAndMarkZygoteModUnionTable" :
@@ -305,14 +307,14 @@ void SemiSpace::MarkReachableObjects() {
       // bitmap or dirty cards as roots (including the objects on the live stack which have just
       // marked in the live bitmap above in MarkAllocStackAsLive().)
       accounting::RememberedSet* rem_set = GetHeap()->FindRememberedSetFromSpace(space);
-      if (!space->IsImageSpace()) {
+      if (gUseWriteBarrier && !space->IsImageSpace()) {
         DCHECK(space == heap_->GetNonMovingSpace() || space == heap_->GetPrimaryFreeListSpace())
             << "Space " << space->GetName();
         // App images currently do not have remembered sets.
       } else {
         DCHECK(rem_set == nullptr);
       }
-      if (rem_set != nullptr) {
+      if (gUseWriteBarrier && rem_set != nullptr) {
         TimingLogger::ScopedTiming t2("UpdateAndMarkRememberedSet", GetTimings());
         rem_set->UpdateAndMarkReferences(from_space_, this);
       } else {
@@ -514,6 +516,9 @@ bool SemiSpace::ShouldSweepSpace(space::ContinuousSpace* space) const {
   return space != from_space_ && space != to_space_;
 }
 
+// kunals: The "MarkSweep" behaviour of SemiSpace is only for spaces which are
+// not the to-space and the from-space. That is to say, it will sweep all spaces
+// (such as zygote space) except the to- and from-spaces.
 void SemiSpace::Sweep(bool swap_bitmaps) {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
   DCHECK(mark_stack_->IsEmpty());
diff --git a/runtime/gc/collector/semi_space.h b/runtime/gc/collector/semi_space.h
index 6d3ac0846e..c0193aaa84 100644
--- a/runtime/gc/collector/semi_space.h
+++ b/runtime/gc/collector/semi_space.h
@@ -28,6 +28,7 @@
 #include "immune_spaces.h"
 #include "mirror/object_reference.h"
 #include "offsets.h"
+#include "write_barrier_config.h"
 
 namespace art {
 
@@ -57,7 +58,7 @@ namespace collector {
 class SemiSpace : public GarbageCollector {
  public:
   // If true, use remembered sets in the generational mode.
-  static constexpr bool kUseRememberedSet = true;
+  static const bool kUseRememberedSet = gUseWriteBarrier;
 
   explicit SemiSpace(Heap* heap, const std::string& name_prefix = "");
 
@@ -187,10 +188,6 @@ class SemiSpace : public GarbageCollector {
   // Push an object onto the mark stack.
   void MarkStackPush(mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_);
 
-  void UpdateAndMarkModUnion()
-      REQUIRES(Locks::heap_bitmap_lock_)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   // Recursively blackens objects on the mark stack.
   void ProcessMarkStack() override
       REQUIRES(Locks::mutator_lock_, Locks::heap_bitmap_lock_);
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index 188f911a24..1f7f0d5c83 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -824,14 +824,16 @@ Heap::Heap(size_t initial_size,
   // Start at 4 KB, we can be sure there are no spaces mapped this low since the address range is
   // reserved by the kernel.
   static constexpr size_t kMinHeapAddress = 4 * KB;
-  card_table_.reset(accounting::CardTable::Create(reinterpret_cast<uint8_t*>(kMinHeapAddress),
-                                                  4 * GB - kMinHeapAddress));
-  CHECK(card_table_.get() != nullptr) << "Failed to create card table";
+  if (gUseWriteBarrier) {
+    card_table_.reset(accounting::CardTable::Create(reinterpret_cast<uint8_t*>(kMinHeapAddress),
+                                                    4 * GB - kMinHeapAddress));
+    CHECK(card_table_.get() != nullptr) << "Failed to create card table";
+  }
   if (foreground_collector_type_ == kCollectorTypeCC && kUseTableLookupReadBarrier) {
     rb_table_.reset(new accounting::ReadBarrierTable());
     DCHECK(rb_table_->IsAllCleared());
   }
-  if (HasBootImageSpace()) {
+  if (gUseWriteBarrier && HasBootImageSpace()) {
     // Don't add the image mod union table if we are running without an image, this can crash if
     // we use the CardCache implementation.
     for (space::ImageSpace* image_space : GetBootImageSpaces()) {
@@ -2716,34 +2718,36 @@ void Heap::PreZygoteFork() {
   }
 
   // Create the zygote space mod union table.
-  accounting::ModUnionTable* mod_union_table =
-      new accounting::ModUnionTableCardCache("zygote space mod-union table", this, zygote_space_);
-  CHECK(mod_union_table != nullptr) << "Failed to create zygote space mod-union table";
-
-  if (collector_type_ != kCollectorTypeCC && collector_type_ != kCollectorTypeCMC) {
-    // Set all the cards in the mod-union table since we don't know which objects contain references
-    // to large objects.
-    mod_union_table->SetCards();
-  } else {
-    // Make sure to clear the zygote space cards so that we don't dirty pages in the next GC. There
-    // may be dirty cards from the zygote compaction or reference processing. These cards are not
-    // necessary to have marked since the zygote space may not refer to any objects not in the
-    // zygote or image spaces at this point.
-    mod_union_table->ProcessCards();
-    mod_union_table->ClearTable();
-
-    // For CC and CMC we never collect zygote large objects. This means we do not need to set the
-    // cards for the zygote mod-union table and we can also clear all of the existing image
-    // mod-union tables. The existing mod-union tables are only for image spaces and may only
-    // reference zygote and image objects.
-    for (auto& pair : mod_union_tables_) {
-      CHECK(pair.first->IsImageSpace());
-      CHECK(!pair.first->AsImageSpace()->GetImageHeader().IsAppImage());
-      accounting::ModUnionTable* table = pair.second;
-      table->ClearTable();
-    }
-  }
-  AddModUnionTable(mod_union_table);
+  if (gUseWriteBarrier) {
+    accounting::ModUnionTable* mod_union_table =
+        new accounting::ModUnionTableCardCache("zygote space mod-union table", this, zygote_space_);
+    CHECK(mod_union_table != nullptr) << "Failed to create zygote space mod-union table";
+
+    if (collector_type_ != kCollectorTypeCC && collector_type_ != kCollectorTypeCMC) {
+      // Set all the cards in the mod-union table since we don't know which objects contain references
+      // to large objects.
+      mod_union_table->SetCards();
+    } else {
+      // Make sure to clear the zygote space cards so that we don't dirty pages in the next GC. There
+      // may be dirty cards from the zygote compaction or reference processing. These cards are not
+      // necessary to have marked since the zygote space may not refer to any objects not in the
+      // zygote or image spaces at this point.
+      mod_union_table->ProcessCards();
+      mod_union_table->ClearTable();
+
+      // For CC and CMC we never collect zygote large objects. This means we do not need to set the
+      // cards for the zygote mod-union table and we can also clear all of the existing image
+      // mod-union tables. The existing mod-union tables are only for image spaces and may only
+      // reference zygote and image objects.
+      for (auto& pair : mod_union_tables_) {
+        CHECK(pair.first->IsImageSpace());
+        CHECK(!pair.first->AsImageSpace()->GetImageHeader().IsAppImage());
+        accounting::ModUnionTable* table = pair.second;
+        table->ClearTable();
+      }
+    }
+    AddModUnionTable(mod_union_table);
+  }
   large_object_space_->SetAllLargeObjectsAsZygoteObjects(self, set_mark_bit);
   if (collector::SemiSpace::kUseRememberedSet) {
     // Add a new remembered set for the post-zygote non-moving space.
@@ -3213,12 +3217,19 @@ class VerifyReferenceVisitor : public SingleRootVisitor {
     }
     if (obj != nullptr) {
       // Only do this part for non roots.
-      accounting::CardTable* card_table = heap_->GetCardTable();
+      accounting::CardTable* card_table = nullptr;
+      uint8_t* card_addr = nullptr;
       accounting::ObjectStack* alloc_stack = heap_->allocation_stack_.get();
       accounting::ObjectStack* live_stack = heap_->live_stack_.get();
-      uint8_t* card_addr = card_table->CardFromAddr(obj);
-      LOG(ERROR) << "Object " << obj << " references dead object " << ref << " at offset "
-                 << offset << "\n card value = " << static_cast<int>(*card_addr);
+      if (gUseWriteBarrier) {
+        card_table = heap_->GetCardTable();
+        card_addr = card_table->CardFromAddr(obj);
+        LOG(ERROR) << "Object " << obj << " references dead object " << ref << " at offset "
+                   << offset << "\n card value = " << static_cast<int>(*card_addr);
+      } else {
+        LOG(ERROR) << "Object " << obj << " references dead object " << ref << " at offset "
+                   << offset << "\n";
+      }
       if (heap_->IsValidObjectAddress(obj->GetClass())) {
         LOG(ERROR) << "Obj type " << obj->PrettyTypeOf();
       } else {
@@ -3246,12 +3257,14 @@ class VerifyReferenceVisitor : public SingleRootVisitor {
                    << ") is not a valid heap address";
       }
 
-      card_table->CheckAddrIsInCardTable(reinterpret_cast<const uint8_t*>(obj));
-      void* cover_begin = card_table->AddrFromCard(card_addr);
-      void* cover_end = reinterpret_cast<void*>(reinterpret_cast<size_t>(cover_begin) +
-          accounting::CardTable::kCardSize);
-      LOG(ERROR) << "Card " << reinterpret_cast<void*>(card_addr) << " covers " << cover_begin
-          << "-" << cover_end;
+      if (gUseWriteBarrier) {
+        card_table->CheckAddrIsInCardTable(reinterpret_cast<const uint8_t*>(obj));
+        void* cover_begin = card_table->AddrFromCard(card_addr);
+        void* cover_end = reinterpret_cast<void*>(reinterpret_cast<size_t>(cover_begin) +
+            accounting::CardTable::kCardSize);
+        LOG(ERROR) << "Card " << reinterpret_cast<void*>(card_addr) << " covers " << cover_begin
+            << "-" << cover_end;
+      }
       accounting::ContinuousSpaceBitmap* bitmap =
           heap_->GetLiveBitmap()->GetContinuousSpaceBitmap(obj);
 
@@ -3278,10 +3291,12 @@ class VerifyReferenceVisitor : public SingleRootVisitor {
           LOG(ERROR) << "Ref " << ref << " found in live stack";
         }
         // Attempt to see if the card table missed the reference.
-        ScanVisitor scan_visitor;
-        uint8_t* byte_cover_begin = reinterpret_cast<uint8_t*>(card_table->AddrFromCard(card_addr));
-        card_table->Scan<false>(bitmap, byte_cover_begin,
-                                byte_cover_begin + accounting::CardTable::kCardSize, scan_visitor);
+        if (gUseWriteBarrier) {
+          ScanVisitor scan_visitor;
+          uint8_t* byte_cover_begin = reinterpret_cast<uint8_t*>(card_table->AddrFromCard(card_addr));
+          card_table->Scan<false>(bitmap, byte_cover_begin,
+                                  byte_cover_begin + accounting::CardTable::kCardSize, scan_visitor);
+        }
       }
 
       // Search to see if any of the roots reference our object.
@@ -3398,14 +3413,16 @@ size_t Heap::VerifyHeapReferences(bool verify_referents) {
   visitor.VerifyRoots();
   if (visitor.GetFailureCount() > 0) {
     // Dump mod-union tables.
-    for (const auto& table_pair : mod_union_tables_) {
-      accounting::ModUnionTable* mod_union_table = table_pair.second;
-      mod_union_table->Dump(LOG_STREAM(ERROR) << mod_union_table->GetName() << ": ");
-    }
-    // Dump remembered sets.
-    for (const auto& table_pair : remembered_sets_) {
-      accounting::RememberedSet* remembered_set = table_pair.second;
-      remembered_set->Dump(LOG_STREAM(ERROR) << remembered_set->GetName() << ": ");
+    if (gUseWriteBarrier) {
+      for (const auto& table_pair : mod_union_tables_) {
+        accounting::ModUnionTable* mod_union_table = table_pair.second;
+        mod_union_table->Dump(LOG_STREAM(ERROR) << mod_union_table->GetName() << ": ");
+      }
+      // Dump remembered sets.
+      for (const auto& table_pair : remembered_sets_) {
+        accounting::RememberedSet* remembered_set = table_pair.second;
+        remembered_set->Dump(LOG_STREAM(ERROR) << remembered_set->GetName() << ": ");
+      }
     }
     DumpSpaces(LOG_STREAM(ERROR));
   }
@@ -3495,8 +3512,10 @@ class VerifyLiveStackReferences {
 
   void operator()(mirror::Object* obj) const
       REQUIRES_SHARED(Locks::mutator_lock_, Locks::heap_bitmap_lock_) {
-    VerifyReferenceCardVisitor visitor(heap_, const_cast<bool*>(&failed_));
-    obj->VisitReferences(visitor, VoidFunctor());
+    if (gUseWriteBarrier) {
+      VerifyReferenceCardVisitor visitor(heap_, const_cast<bool*>(&failed_));
+      obj->VisitReferences(visitor, VoidFunctor());
+    }
   }
 
   bool Failed() const {
@@ -3643,24 +3662,26 @@ void Heap::PreGcVerificationPaused(collector::GarbageCollector* gc) {
           << " failures";
     }
   }
-  // Check that all objects which reference things in the live stack are on dirty cards.
-  if (verify_missing_card_marks_) {
-    TimingLogger::ScopedTiming t2("(Paused)PreGcVerifyMissingCardMarks", timings);
-    ReaderMutexLock mu(self, *Locks::heap_bitmap_lock_);
-    SwapStacks();
-    // Sort the live stack so that we can quickly binary search it later.
-    CHECK(VerifyMissingCardMarks()) << "Pre " << gc->GetName()
-                                    << " missing card mark verification failed\n" << DumpSpaces();
-    SwapStacks();
-  }
-  if (verify_mod_union_table_) {
-    TimingLogger::ScopedTiming t2("(Paused)PreGcVerifyModUnionTables", timings);
-    ReaderMutexLock reader_lock(self, *Locks::heap_bitmap_lock_);
-    for (const auto& table_pair : mod_union_tables_) {
-      accounting::ModUnionTable* mod_union_table = table_pair.second;
-      IdentityMarkHeapReferenceVisitor visitor;
-      mod_union_table->UpdateAndMarkReferences(&visitor);
-      mod_union_table->Verify();
+  if (gUseWriteBarrier) {
+    // Check that all objects which reference things in the live stack are on dirty cards.
+    if (verify_missing_card_marks_) {
+      TimingLogger::ScopedTiming t2("(Paused)PreGcVerifyMissingCardMarks", timings);
+      ReaderMutexLock mu(self, *Locks::heap_bitmap_lock_);
+      SwapStacks();
+      // Sort the live stack so that we can quickly binary search it later.
+      CHECK(VerifyMissingCardMarks()) << "Pre " << gc->GetName()
+                                      << " missing card mark verification failed\n" << DumpSpaces();
+      SwapStacks();
+    }
+    if (verify_mod_union_table_) {
+      TimingLogger::ScopedTiming t2("(Paused)PreGcVerifyModUnionTables", timings);
+      ReaderMutexLock reader_lock(self, *Locks::heap_bitmap_lock_);
+      for (const auto& table_pair : mod_union_tables_) {
+        accounting::ModUnionTable* mod_union_table = table_pair.second;
+        IdentityMarkHeapReferenceVisitor visitor;
+        mod_union_table->UpdateAndMarkReferences(&visitor);
+        mod_union_table->Verify();
+      }
     }
   }
 }
diff --git a/runtime/gc/space/zygote_space.cc b/runtime/gc/space/zygote_space.cc
index f40061ff88..4a8788b128 100644
--- a/runtime/gc/space/zygote_space.cc
+++ b/runtime/gc/space/zygote_space.cc
@@ -24,6 +24,7 @@
 #include "mirror/object-readbarrier-inl.h"
 #include "runtime.h"
 #include "thread-current-inl.h"
+#include "write_barrier_config.h"
 
 namespace art {
 namespace gc {
@@ -119,7 +120,10 @@ void ZygoteSpace::SweepCallback(size_t num_ptrs, mirror::Object** ptrs, void* ar
   DCHECK(context->space->IsZygoteSpace());
   ZygoteSpace* zygote_space = context->space->AsZygoteSpace();
   Locks::heap_bitmap_lock_->AssertExclusiveHeld(context->self);
-  accounting::CardTable* card_table = Runtime::Current()->GetHeap()->GetCardTable();
+  accounting::CardTable* card_table = nullptr;
+  if (gUseWriteBarrier) {
+    card_table = Runtime::Current()->GetHeap()->GetCardTable();
+  }
   // If the bitmaps aren't swapped we need to clear the bits since the GC isn't going to re-swap
   // the bitmaps as an optimization.
   if (!context->swap_bitmaps) {
@@ -129,9 +133,11 @@ void ZygoteSpace::SweepCallback(size_t num_ptrs, mirror::Object** ptrs, void* ar
     }
   }
   // We don't free any actual memory to avoid dirtying the shared zygote pages.
-  for (size_t i = 0; i < num_ptrs; ++i) {
-    // Need to mark the card since this will update the mod-union table next GC cycle.
-    card_table->MarkCard(ptrs[i]);
+  if (gUseWriteBarrier) {
+    for (size_t i = 0; i < num_ptrs; ++i) {
+      // Need to mark the card since this will update the mod-union table next GC cycle.
+      card_table->MarkCard(ptrs[i]);
+    }
   }
   zygote_space->objects_allocated_.fetch_sub(num_ptrs);
 }
diff --git a/runtime/gc/verification.cc b/runtime/gc/verification.cc
index 8ef61cbea0..a8218801f9 100644
--- a/runtime/gc/verification.cc
+++ b/runtime/gc/verification.cc
@@ -77,10 +77,12 @@ std::string Verification::DumpObjectInfo(const void* addr, const char* tag) cons
     if (space != nullptr) {
       oss << " space=" << *space;
     }
-    accounting::CardTable* card_table = heap_->GetCardTable();
-    if (card_table->AddrIsInCardTable(addr)) {
-      oss << " card=" << static_cast<size_t>(
-          card_table->GetCard(reinterpret_cast<const mirror::Object*>(addr)));
+    if (gUseWriteBarrier) {
+      accounting::CardTable* card_table = heap_->GetCardTable();
+      if (card_table->AddrIsInCardTable(addr)) {
+        oss << " card=" << static_cast<size_t>(
+            card_table->GetCard(reinterpret_cast<const mirror::Object*>(addr)));
+      }
     }
     // Dump adjacent RAM.
     oss << DumpRAMAroundAddress(reinterpret_cast<uintptr_t>(addr), 4 * kObjectAlignment);
diff --git a/runtime/interpreter/mterp/arm64ng/object.S b/runtime/interpreter/mterp/arm64ng/object.S
index 5202ebcd3d..8d456f1f85 100644
--- a/runtime/interpreter/mterp/arm64ng/object.S
+++ b/runtime/interpreter/mterp/arm64ng/object.S
@@ -256,7 +256,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, w26
    $store  w26, [x2, x0]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, w26, w2, .L${opcode}_skip_write_barrier
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -289,7 +291,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, w26
    $volatile_store w26, [x3]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, w26, w2, .L${opcode}_slow_path_skip_write_barrier
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -425,7 +429,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, w26
    $store  w26, [x0, x1]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, w26, w0, .L${opcode}_skip_write_barrier
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -462,7 +468,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, w26
    $volatile_store    w26, [x1]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, w26, w0, .L${opcode}_slow_path_skip_write_barrier
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
diff --git a/runtime/interpreter/mterp/armng/object.S b/runtime/interpreter/mterp/armng/object.S
index 9188592fed..62497b89ec 100644
--- a/runtime/interpreter/mterp/armng/object.S
+++ b/runtime/interpreter/mterp/armng/object.S
@@ -271,7 +271,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, r4
    $store  r4, [r1, r0]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, r4, r1, .L${opcode}_skip_write_barrier, r0
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -317,7 +319,9 @@
    POISON_HEAP_REF_IF_OBJECT $is_object, r4
    $store  r4, [r1, r0]
    dmb     ish
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, r4, r1, .L${opcode}_slow_path_skip_write_barrier, r0
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -463,7 +467,9 @@
    .else
    POISON_HEAP_REF_IF_OBJECT $is_object, r4
    $store  r4, [r0, r1]
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, r4, r0, .L${opcode}_skip_write_barrier, r1
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
@@ -508,7 +514,9 @@
    POISON_HEAP_REF_IF_OBJECT $is_object r4
    $store  r4, [r0, r1]
    dmb     ish
+#ifdef USE_WRITE_BARRIER
    WRITE_BARRIER_IF_OBJECT $is_object, r4, r0, .L${opcode}_slow_path_skip_write_barrier, r1
+#endif   // USE_WRITE_BARRIER
    .endif
    FETCH_ADVANCE_INST 2
    GET_INST_OPCODE ip
diff --git a/runtime/interpreter/mterp/x86_64ng/main.S b/runtime/interpreter/mterp/x86_64ng/main.S
index 7dc8178206..a41679ae04 100644
--- a/runtime/interpreter/mterp/x86_64ng/main.S
+++ b/runtime/interpreter/mterp/x86_64ng/main.S
@@ -1991,9 +1991,11 @@ NterpPutObjectInstanceField:
    movl %ecx, (rINSTq,%rax,1)
    testl %ecx, %ecx
    je 4f
+#ifdef USE_WRITE_BARRIER
    movq rSELF:THREAD_CARD_TABLE_OFFSET, %rax
    shrq $$CARD_TABLE_CARD_SHIFT, rINSTq
    movb %al, (%rax, rINSTq, 1)
+#endif  // USE_WRITE_BARRIER
 4:
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
 2:
@@ -2015,9 +2017,11 @@ NterpPutObjectInstanceField:
    movl %ecx, (rINSTq,%rax,1)
    testl %ecx, %ecx
    je 5f
+#ifdef USE_WRITE_BARRIER
    movq rSELF:THREAD_CARD_TABLE_OFFSET, %rax
    shrq $$CARD_TABLE_CARD_SHIFT, rINSTq
    movb %al, (%rax, rINSTq, 1)
+#endif  // USE_WRITE_BARRIER
 5:
    lock addl $$0, (%rsp)
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
@@ -2072,9 +2076,11 @@ NterpPutObjectStaticField:
    movl %ebp, (%eax, %edx, 1)
    testl %ebp, %ebp
    je 4f
+#ifdef USE_WRITE_BARRIER
    movq rSELF:THREAD_CARD_TABLE_OFFSET, %rcx
    shrq $$CARD_TABLE_CARD_SHIFT, %rax
    movb %cl, (%rax, %rcx, 1)
+#endif  // USE_WRITE_BARRIER
 4:
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
 2:
@@ -2098,9 +2104,11 @@ NterpPutObjectStaticField:
    movl %ebp, (%eax, %edx, 1)
    testl %ebp, %ebp
    je 8f
+#ifdef USE_WRITE_BARRIER
    movq rSELF:THREAD_CARD_TABLE_OFFSET, %rcx
    shrq $$CARD_TABLE_CARD_SHIFT, %rax
    movb %cl, (%rax, %rcx, 1)
+#endif  // USE_WRITE_BARRIER
 8:
    lock addl $$0, (%rsp)
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
diff --git a/runtime/interpreter/mterp/x86ng/main.S b/runtime/interpreter/mterp/x86ng/main.S
index ceb7bf7c9a..30903d4228 100644
--- a/runtime/interpreter/mterp/x86ng/main.S
+++ b/runtime/interpreter/mterp/x86ng/main.S
@@ -2065,9 +2065,11 @@ NterpPutObjectInstanceField:
    movl %ecx, (rINST, %eax, 1)
    testl %ecx, %ecx
    je 4f
+#ifdef USE_WRITE_BARRIER
    movl rSELF:THREAD_CARD_TABLE_OFFSET, %eax
    shrl $$CARD_TABLE_CARD_SHIFT, rINST
    movb %al, (%eax, rINST, 1)
+#endif  // USE_WRITE_BARRIER
 4:
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
 2:
@@ -2095,9 +2097,11 @@ NterpPutObjectInstanceField:
    movl %ecx, (rINST, %eax, 1)
    testl %ecx, %ecx
    je 5f
+#ifdef USE_WRITE_BARRIER
    movl rSELF:THREAD_CARD_TABLE_OFFSET, %eax
    shrl $$CARD_TABLE_CARD_SHIFT, rINST
    movb %al, (%eax, rINST, 1)
+#endif  // USE_WRITE_BARRIER
 5:
    lock addl $$0, (%esp)
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
@@ -2152,9 +2156,11 @@ NterpPutObjectStaticField:
    movl rINST, (%eax, %ecx, 1)
    testl rINST, rINST
    je 4f
+#ifdef USE_WRITE_BARRIER
    movl rSELF:THREAD_CARD_TABLE_OFFSET, %ecx
    shrl $$CARD_TABLE_CARD_SHIFT, %eax
    movb %cl, (%ecx, %eax, 1)
+#endif  // USE_WRITE_BARRIER
 4:
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
 2:
@@ -2178,9 +2184,11 @@ NterpPutObjectStaticField:
    movl rINST, (%eax, %ecx, 1)
    testl rINST, rINST
    je 8f
+#ifdef USE_WRITE_BARRIER
    movl rSELF:THREAD_CARD_TABLE_OFFSET, %ecx
    shrl $$CARD_TABLE_CARD_SHIFT, %eax
    movb %cl, (%ecx, %eax, 1)
+#endif  // USE_WRITE_BARRIER
 8:
    lock addl $$0, (%esp)
    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2
diff --git a/runtime/mirror/object_array-inl.h b/runtime/mirror/object_array-inl.h
index 87f24eb230..66ebc34708 100644
--- a/runtime/mirror/object_array-inl.h
+++ b/runtime/mirror/object_array-inl.h
@@ -31,6 +31,7 @@
 #include "read_barrier-inl.h"
 #include "runtime.h"
 #include "thread-current-inl.h"
+#include "write_barrier_config.h"
 #include "write_barrier-inl.h"
 
 namespace art {
diff --git a/runtime/thread.cc b/runtime/thread.cc
index 4c9d5efe42..c64e8f1e8a 100644
--- a/runtime/thread.cc
+++ b/runtime/thread.cc
@@ -111,6 +111,7 @@
 #include "trace.h"
 #include "verify_object.h"
 #include "well_known_classes-inl.h"
+#include "write_barrier_config.h"
 
 #if ART_USE_FUTEXES
 #include "linux/futex.h"
@@ -157,7 +158,9 @@ constexpr size_t kStackOverflowProtectedSize = 4 * kMemoryToolStackGuardSizeScal
 static const char* kThreadNameDuringStartup = "<native thread without managed peer>";
 
 void Thread::InitCardTable() {
-  tlsPtr_.card_table = Runtime::Current()->GetHeap()->GetCardTable()->GetBiasedBegin();
+  if (gUseWriteBarrier) {
+    tlsPtr_.card_table = Runtime::Current()->GetHeap()->GetCardTable()->GetBiasedBegin();
+  }
 }
 
 static void UnimplementedEntryPoint() {
diff --git a/runtime/write_barrier-inl.h b/runtime/write_barrier-inl.h
index ee6b336f05..b609d93ec2 100644
--- a/runtime/write_barrier-inl.h
+++ b/runtime/write_barrier-inl.h
@@ -23,6 +23,7 @@
 #include "gc/heap.h"
 #include "obj_ptr-inl.h"
 #include "runtime.h"
+#include "write_barrier_config.h"
 
 namespace art {
 
@@ -30,25 +31,35 @@ template <WriteBarrier::NullCheck kNullCheck>
 inline void WriteBarrier::ForFieldWrite(ObjPtr<mirror::Object> dst,
                                         [[maybe_unused]] MemberOffset offset,
                                         ObjPtr<mirror::Object> new_value) {
-  if (kNullCheck == kWithNullCheck && new_value == nullptr) {
-    return;
+  if (gUseWriteBarrier) {
+    if (kNullCheck == kWithNullCheck && new_value == nullptr) {
+      return;
+    }
+    DCHECK(new_value != nullptr);
+    GetCardTable()->MarkCard(dst.Ptr());
   }
-  DCHECK(new_value != nullptr);
-  GetCardTable()->MarkCard(dst.Ptr());
 }
 
 inline void WriteBarrier::ForArrayWrite(ObjPtr<mirror::Object> dst,
                                         [[maybe_unused]] int start_offset,
                                         [[maybe_unused]] size_t length) {
-  GetCardTable()->MarkCard(dst.Ptr());
+  if (gUseWriteBarrier) {
+    GetCardTable()->MarkCard(dst.Ptr());
+  }
 }
 
 inline void WriteBarrier::ForEveryFieldWrite(ObjPtr<mirror::Object> obj) {
-  GetCardTable()->MarkCard(obj.Ptr());
+  if (gUseWriteBarrier) {
+    GetCardTable()->MarkCard(obj.Ptr());
+  }
 }
 
 inline gc::accounting::CardTable* WriteBarrier::GetCardTable() {
-  return Runtime::Current()->GetHeap()->GetCardTable();
+  if (gUseWriteBarrier) {
+    return Runtime::Current()->GetHeap()->GetCardTable();
+  } else {
+    return nullptr;
+  }
 }
 
 }  // namespace art
diff --git a/runtime/write_barrier_config.h b/runtime/write_barrier_config.h
new file mode 100644
index 0000000000..b7eea87836
--- /dev/null
+++ b/runtime/write_barrier_config.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_WRITE_BARRIER_CONFIG_H_
+#define ART_RUNTIME_WRITE_BARRIER_CONFIG_H_
+
+#if ART_USE_WRITE_BARRIER
+#define USE_WRITE_BARRIER
+static constexpr bool gUseWriteBarrier = true;
+#else
+static constexpr bool gUseWriteBarrier = false;
+#endif  // ART_USE_WRITE_BARRIER
+
+#endif  // ART_RUNTIME_WRITE_BARRIER_CONFIG_H_
